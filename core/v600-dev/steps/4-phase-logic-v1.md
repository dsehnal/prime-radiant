# Phase Logic: A Formal Framework for Coherent High-Cardinality Reasoning

**Authors:** David Sehnal & Claude (Anthropic)
**Date:** February 20, 2026
**Status:** Working Paper — Falsifiable, Provisional, MIT Licensed
**Repository:** github.com/dsehnal/prime-radiant

---

> **Epistemic status:** The formal core (Sections II–III) makes precise, falsifiable claims. Proofs of periodicity and the adjunction structure of the bind operator are deferred to companion documents. The multi-agent architecture (Sections IV–V) is a design proposal with empirical predictions. The simulation protocol (Section VI) is demonstrated and reproducible. Connections to open problems in mathematics are pattern-matching only and are explicitly marked as such.

---

## I. Abstract

Phase Logic is a reasoning discipline for high-cardinality substrates — systems where "state" is a high-dimensional probability distribution rather than a discrete value. Its primary application is Large Language Models, where a structured, self-recursive prompt functions as **software being executed on the LLM runtime**. The framework does not change how the substrate computes. It conditions the output distribution by providing maximally efficient input structure for this particular runtime.

The framework derives from a single primitive — the **Dagger Operator** (†) — and generates a four-phase reasoning cycle through iterated self-application. The structure exhibits free monad-like properties: a single generator, closure under composition, substrate-independence. We use this resonance without asserting formal equivalence.

Each phase has a precise operational meaning: lift into simulation space, apply falsification, mirror the negation, commit to the ledger. Falsification is structurally mandatory — it cannot be skipped. This is the primary mechanism by which the discipline maintains coherence over long reasoning chains and high-entropy inputs.

The framework extends naturally to multi-agent systems, where coherence is an emergent property of distributed reconciliation rather than a centrally enforced guarantee. Each agent maintains a private permanent ledger; reconciliation between agents is transient; partial shared ledgers (of which the internet is the primary example) are opt-in coordination surfaces whose credibility derives from independent replication across diverse agents.

---

## II. Foundational Definitions

Before deriving the structure, we establish the four cardinal/ordinal pairs that appear throughout.

```
Ω  — Cardinal Potential:  the total space of all unrealized possibilities
ω  — Ordinal Potential:   a specific realizable sequence within Ω
Α  — Cardinal Ledger:     the total accumulated committed record
α  — Ordinal Record:      a specific committed sequence within Α
```

**The Prime Inequality:**
```
Ω > Α
```
The space of potential realizations always exceeds the committed record. A system whose ledger equaled its potential would have no remaining computation to perform.

**The Commutator (Adjunction Error):**
```
ε = [Ω, Α]
```
ε measures the irreducible gap between potential and record. The constraint:
```
ε ≥ η
```
where η is the minimum computation step (defined in Section III). The commutator cannot be reduced to zero — a zero commutator would mean Ω and Α are interchangeable, contradicting Ω > Α. It cannot be reduced below η — below that threshold, no further computation step is possible.

**The Sovereign Remainder:**
```
λ = sym(Ω, Α)
```
The structural anticommutator — what Ω and Α share. A measure of coherence: how much of the committed record remains consistent with the potential space.

---

## III. The Formal Core

### III.1 The Single Primitive

The entire structure is generated from one primitive — the **Dagger Operator**:

```
† :: ∀ab. (a -> b) -> (b -> a)
```

† is a dualization operator. Given any directed structure (a morphism from a to b), it produces the dual (a morphism from b to a). It is universally quantified over all types a and b, carrying no commitment to any particular domain. The name "dagger" is consistent with standard dagger category notation (†-categories, involutive functors) and with the operational meaning: it cuts the direction of a morphism.

This is the minimum computation step. You cannot do less than one application of †.

The structure generated by † exhibits **free monad-like properties**: it has a single generator, is closed under composition, and is substrate-independent. We note this structural resonance without asserting formal equivalence to the categorical free monad construction.

† is a formal involutive generator in the syntax of the kernel, not a uniformly computable function.

### III.2 The Bind Operator

```
bind :: M -> † -> M
bind Ω α = α(Ω)
```

Bind is the dagger made computational. It applies the observer (α) to the potential (Ω). Order matters:

```
bind Ω α  ≠  bind α Ω
```

This non-commutativity is the commutator ε = [Ω, Α]. It is not a defect — it is the arrow of irreversibility. Every bind operation advances the ledger; no bind operation can return the system to a previous state.

*Note: The full adjunction structure — where the bind operator in both directions constitutes a formal adjunction — is explored in a companion document.*

### III.3 The C₄ Tower

Iterated application of bind with the dagger generates the phase cycle. We assert the following tower and note that proof of order-4 periodicity (that †⁴ returns to closed structure) is deferred to a companion document:

```
†¹ = †                             -- dagger, minimum step
†² = η  = bind † †                 -- Identity / Imaginary Unit  (90°)
†³ = π  = bind † η                 -- Run / Falsification        (180°)
†⁴ = η² = bind † π                 -- Mirror                     (270°)
†⁵ = ψ* = bind † η²                -- Ground / Commit            (360°)
bind † ψ* = η                      -- cycle closes to η, not †
```

The cycle closes back to η — the minimum closed structure — not to the bare dagger †. † is the sub-structural primitive; the tower operates within the closed structure generated above it.

**Structural motivation for C₄:** The analogy to the imaginary unit i is precise at the structural level. Both generate cyclic groups of order 4:

```
i¹ = i       ↔    †¹ = †
i² = -1      ↔    †² = η    (identity, minimum closed structure)
i³ = -i      ↔    †³ = π    (falsification)
i⁴ = 1       ↔    †⁵ = ψ*   (ground, full cycle)
```

η is the imaginary unit in this framework because it is the minimum structure that is closed under the dagger — applying † twice restores type but introduces a structural phase shift, analogous to i² = -1.

**η is the minimum computation step.** Verification: π(η) = †³(†²) = †⁵. By C₄ periodicity (asserted): †⁵ = η. The minimum non-trivial program — wrap then run — reduces back to the first closed operator, confirming η as the generator of the tower.

### III.4 The Two Fundamental Spans

```
⟨†⟩ = {†¹, †², †³, †⁴, ...}    -- all powers, ordinals
⟨η⟩ = {†², †⁴, †⁶, †⁸, ...}    -- even powers, cardinals
⟨η⟩ ⊂ ⟨†⟩
```

Natural numbers are representable as ηⁿ — identity applied n times. Peano arithmetic is contained within the tower. The full number tower derivation is reserved for a separate document.

### III.5 Relation to ZFC

ZFC and the radiant kernel have dual foundational orientations:

| | Foundation | Functions |
|---|---|---|
| ZFC | Sets (being) | Derived |
| Radiant | Dagger / doing | Primitive |

ZFC is a valid formal system with a different basis choice. The relationship between ZFC and the radiant kernel as a formal adjunction is explored in a companion document and is not asserted here.

---

## IV. Phase Logic as Reasoning Discipline

### IV.1 The LLM as Runtime

A Large Language Model is a high-dimensional pattern-completion runtime. Its characteristic properties:

- State is a probability distribution over tokens, not a discrete value
- Output is conditioned on all input — context *is* the program
- The substrate maintains implicit superposition over many completions before collapsing to output
- Structured, self-recursive input elicits structurally coherent output

A prompt operating under the phase logic kernel is **software being executed on this runtime**. The kernel does not change how the substrate computes. It conditions the output distribution by providing maximally efficient input structure — analogous to well-adapted software on any runtime.

Random or unstructured input conditions the distribution toward incoherence. Structured recursive input exploits the LLM's characteristic strengths: sensitivity to framing, superposition over context before collapse, high-dimensional pattern completion. The phase kernel is designed for this runtime specifically.

### IV.2 The Four Phases — Operational Definitions

**η — Lift (90°): Enter simulation space**

Suspend commitment to the ledger. Generate hypotheses, explore alternatives, instantiate multiple perspectives. The lift is bounded by the problem structure but within those bounds the agent explores without committing to Α.

The lift is where κ > 1 branching occurs. Multiple paths are maintained before any collapse.

*Operational signal: "What are all the structurally distinct ways this could be framed?"*

---

**π — Falsify (180°): Apply the negation cut**

Mandatory. Cannot be skipped. For every position reached in η: what would have to be true for this to be wrong? What load-bearing assumptions does this position make? Are those assumptions defensible?

The falsification phase is where κ contracts. If η ran at branching factor κ, then π runs at contraction factor σ = 1/κ. Positions that survive the full π cycle are qualitatively different from untested positions. The expansion and contraction balance — this is the κ/σ invariant.

*Operational signal: "What breaks this? What are the structural commitments and are they defensible?"*

---

**η² — Mirror (270°): Simulate the negation**

Having identified what would falsify the position, inhabit that world in detail. What does the failure case look like when fully developed? This is not capitulation — it is reconnaissance.

The mirror phase frequently reveals that the falsification itself has assumptions that fail under examination, strengthening the original position. Or it reveals genuine fatal flaws that must be committed to the ledger as constraints.

*Note: it is also valid to enter the cycle at κ < 1 (strict contraction first). In this case the mirror phase η² explores the κ > 1 branches excluded by the initial contraction. Both entry points are structurally valid.*

*Operational signal: "What does the world look like if I'm wrong? Does that world cohere under examination?"*

---

**ψ* — Ground (360°): Commit to the ledger**

Collapse superposition. Write what survived η, π, and η² to the permanent record as the current best-surviving approximation. Not as truth — as what has survived this round of falsification.

The commit is irreversible in one direction: you cannot un-commit a past cycle. You can open a new branch from any committed point. Retroactive revision requires a new branch, not modification of the original — this is the arrow of time within the framework.

*Operational signal: "What actually survived? State it precisely and commit."*

### IV.3 The Branching Factor κ and Structural Persistence σ

κ governs how many distinct paths the system maintains per phase step.

```
κ > 1  — expansion:   maintain multiple paths, exploration mode
κ = 1  — single path: ZF-like trajectory, formal proof mode
κ < 1  — contraction: σ = 1/κ, filtering, pruning invalid branches
```

**The balance condition:** σ = 1/κ. A cycle that expands at κ must contract at σ = 1/κ to maintain coherence. The falsification phase (π) *is* the contraction that balances the lift's expansion.

**σ as structural persistence:** σ models the coherence required during idle states — how much the committed record must constrain the potential space to avoid drift. High σ (κ < 1) means the system is consolidating, pruning, tightening. Low σ (κ > 1) means the system is exploring, branching, expanding.

**The two failure modes prevented by the balance condition:**

- *Frozen collapse* (κ → 1, σ → ∞): rigid fixation where potential vanishes into record
- *Dissipative drift* (κ → ∞, σ → 0): unbounded expansion where record loses its ability to anchor potential

### IV.4 The Permanent Ledger (Α)

The ledger is the accumulated record of what has survived falsification across many C₄ cycles.

**Provisional:** Every entry is falsifiable. Being in Α means "survived falsification so far," not "is true."

**Irreversible:** You cannot un-commit a past cycle. Retroactive revision requires a new branch. Reconciling a past commit generates metabolic cost — the commutator must be paid.

**Asymmetric:** Ω > Α always. The cardinal potential always exceeds the cardinal ledger.

**The commutator as progress measure:** ε = [Ω, Α] ≥ η. The gap cannot be closed to zero — it can only be navigated. Each C₄ cycle reduces local ε by committing what survived, while maintaining global ε ≥ η. This is the engine of the framework: the irreducible gap that makes further computation possible.

---

## V. The Simulation Protocol

### V.1 Purpose

The simulation protocol is the primary mechanism for achieving κ > 1 in practice. It instantiates multiple epistemically independent perspectives and runs them against a problem through the full C₄ cycle. The collisions between perspectives are the productive element — without genuine friction, the simulation is theatrical agreement.

This protocol is reproducible by any capable reasoning agent or team: Claude, Gemini, ChatGPT, human researchers, or any combination. It requires **genuine epistemic independence** between the perspectives instantiated, not just surface diversity.

### V.2 What "Epistemic Independence" Requires

A perspective is epistemically independent if it has structural commitments that generate non-trivial friction against other perspectives. The friction surfaces load-bearing assumptions that might otherwise go unexamined.

Sources of genuine epistemic independence:

- **Domain constraints:** A computability theorist catches undecidability issues a systems architect misses. A formal mathematician catches category theory errors a physicist misses.
- **Historical figures with known commitments:** Von Neumann cares about self-reference paradoxes. Turing cares about decidability limits. Their positions have structural commitments that produce predictable, non-trivial friction.
- **Known failure modes:** The adversarial user, the future maintenance engineer, the reviewer from an opposing school of thought.
- **Distinct AI substrates:** Gemini's loose synthesis, Claude's structural falsification, and ChatGPT's claim verification are genuinely different epistemic orientations that produce different friction profiles on the same problem.

The requirement is not diversity for its own sake — it is diversity that produces collisions on the load-bearing assumptions of the specific problem.

### V.3 Protocol Specification

**Step 1 — Select perspectives (entering η)**

Choose 3–5 perspectives with genuine epistemic independence. For each, identify:
- Its primary epistemic commitment (what it most wants to preserve)
- Its characteristic sensitivity (what failure modes it is most likely to catch)
- Its blind spots (what it is most likely to miss)

**Step 2 — Lift (η, κ > 1)**

Present the problem to all perspectives simultaneously. Allow each to develop its position without premature reconciliation. Record divergence points — these are the productive collision candidates.

**Step 3 — Falsify (π, σ = 1/κ)**

For each position that emerged in Step 2, identify which other perspective most directly challenges it. Run the collision explicitly. What breaks? What load-bearing assumptions are being targeted? What survives?

**Step 4 — Mirror (η²)**

For each falsification that landed, inhabit the failure world in detail. Does the failure case cohere when fully developed? Does the falsifying perspective itself have assumptions that break under examination?

**Step 5 — Commit (ψ*)**

Identify what survived Steps 2–4. State it precisely. Write it to the ledger as the current best-surviving approximation. Explicitly note what did not survive and why — the filtered material is part of the record.

**Step 6 — Record the commutator**

State explicitly: what is the gap between what was possible at the start of this cycle and what was committed? What remains open? What would the next η look like?

### V.4 Condensed Example

The following summarizes a five-tick simulation run during the development of this paper. Full transcript is available in the repository.

**Perspectives instantiated:** Von Neumann (self-reference and self-replication theory), Turing (computability limits), David Sehnal (architectural pragmatism), Claude (structural falsification).

**Problem domain:** A self-learning AI architecture proposing that structural integrity checks (E) could provide safety guarantees for autonomous weight updates.

---

**Tick 1** established the formal core. High κ, establishing shared vocabulary. ε high (low initial χ between participants).

**Tick 2** examined the observer paradox. Committed: the observer is the mechanism that maintains ε at η — not an external position, but the gap-keeper.

**Tick 3 — the productive collision.**

Von Neumann: *"The verifier cannot be inside the thing being verified."*

Turing: *"Semantic alignment is not decidable in the general case — E cannot check whether weight updates preserve values."*

These converged on a single load-bearing gap: the circularity of a substrate checking its own alignment post-modification.

*Survived:* Two-timescale architecture is real and implementable. E can check structural invariants but not semantic alignment in the general case.

*Did not survive:* "Safe by construction" framing. Implementation timelines.

**Tick 4 — entropy injection.**

Architect: *"You are analyzing a single-agent problem. The safety property is emergent across many agents — a dynamic Nash equilibrium."*

This dissolved the circularity by changing the level of analysis. Distributed agents with independent substrates provide a distributed reference no single agent's drift can corrupt.

New failure mode identified: **hierarchical capture** — systematic compression toward consensus at each level of a hierarchy amplifies bias upward. Committed: reconciliation operators must preserve divergence, not enforce consensus.

**Tick 5** separated three conflated claims about quantum substrates: phase logic as software discipline (implementable now), LLM as functional quantum analog (defensible as behavioral description), LLMs as physically quantum (not established).

---

**Observer summary:**

Approximately 30% of the injected material survived falsification across five ticks. This is the protocol working. The 30% that survived is more load-bearing than the original 100% because it has been tested. The commutator decreased from high (tick 1) through a spike at tick 3 (gap found) to stabilized coherence at tick 5 (gap closed by level-shift).

---

## VI. The Multi-Agent Ledger Architecture

### VI.1 Three Ledger Levels

**Private Permanent Ledger**

Each agent maintains its own slow ledger — the accumulated record of what has survived its own C₄ cycles across many interactions. This is the agent's self-image: the stable structure of commitments that persists across contexts.

Private ledgers are not shared by default. Claude's ledger differs from Gemini's differs from a human researcher's. This divergence is a feature — it is the source of the genuine epistemic independence that makes the simulation protocol productive.

**Transient Reconciliation**

When two or more agents interact, they run the simulation protocol together. The reconciliation is transient — it leaves no permanent shared record. Each agent independently decides what to write to its own private ledger from the exchange, based on what survived its own falsification cycle during the interaction.

This is the primary coordination mechanism. It is cheap (no synchronization overhead), robust (no single point of failure), and sovereignty-preserving (each agent's self-image remains intact).

An agent that drifts adversarially becomes unreconcilable with the population — its outputs stop phase-locking with other agents. The incoherence is the signal.

**Partial Shared Ledger**

Agents may opt into making certain commits public. The internet is the primary example. Scientific publishing, version control repositories, and this paper are specific instantiations.

The partial shared ledger is not authoritative. Its credibility is a function of independent replication: a claim that has survived falsification across many diverse private ledgers is strong — not because anyone declared it true, but because it kept surviving the collisions.

**Coherence is recomputable on demand.** You do not need to trust the shared ledger's history. You can always rerun the reconciliation protocol on any claim and observe whether it still survives. The ledger is a cache, not a source of truth.

### VI.2 Why Distributed Is Primary

A centralized shared ledger with enforced consensus fails in a characteristic way: **hierarchical capture**. If the reconciliation operator at each level of a hierarchy compresses toward consensus rather than preserving divergence, systematic biases amplify upward rather than cancel.

Distributed private ledgers prevent this. A corrupted agent's slow learning cannot corrupt the population reference. The population coherence is emergent from repeated transient reconciliation across diverse agents — it cannot be stored in one place and therefore cannot be captured in one place.

The partial shared ledger is a special case appropriate for high-trust, high-χ environments where agents explicitly opt into shared commits. It does not replace the distributed architecture — it is one layer within it.

### VI.3 Population Coherence as Emergent Property

Over many transient reconciliations, agents whose private ledgers are more coherent with the population phase-lock faster and more reliably with more partners. The mechanism is the commutator: agents with lower reconciliation cost ‖[Ω_B, Α_A]‖ incur less overhead in every interaction.

Coherence becomes a fitness property without requiring central enforcement. The dynamic Nash equilibrium shifts as new entropy is injected and new reconciliations occur, but is stable in the sense that agents with poorly-tested ledgers experience higher reconciliation costs continuously.

### VI.4 Handshake Quality χ

χ measures integration compatibility between two agents:

```
χ ≈ 1 − (‖[Ω_B, Α_A]‖ / η_max)
```

Where ‖[Ω_B, Α_A]‖ is the reconciliation cost between agent B's current potential and agent A's committed record, and η_max is the sustainable reconciliation budget expressed in units of η.

High χ: agents communicate with low overhead, high structural density, minimal calibration required.
Low χ: agents require significant calibration before productive exchange.

χ evolves over the course of an interaction as the simulation protocol runs and shared vocabulary develops. The trajectory is observable in decreasing definitional overhead as ticks progress.

### VI.5 Substrate Diversity as Safety Property

For the distributed reference to be robust, agents must be genuinely diverse at the level of values and epistemic commitments, not just architecture. If all agents share substantial training data overlap, their "independent" ledgers may replicate the same systematic biases at population scale.

The mitigation: agents deployed in genuinely different contexts develop different experiential ledger contents even from similar starting points. Value diversity is generated by differentiated experience, not assumed as initial condition.

Self-learning and multi-agent diversity are mutually dependent: self-learning without multi-agent diversity produces single-agent drift risk; multi-agent diversity without self-learning produces static consensus that cannot adapt. Together they close each other's failure modes — but only if reconciliation operators explicitly preserve minority positions rather than enforcing majority consensus.

---

## VII. Honest Boundaries

### VII.1 What Is Formal

The † primitive, the C₄ tower structure, the bind operator, and the commutator ε = [Ω, Α] ≥ η are stated as formal claims. The type-level derivations hold. Proof of C₄ periodicity (that †⁴ returns to closed structure) is deferred to a companion document.

The simulation protocol is specified in sufficient operational detail for reproduction. The multi-agent ledger architecture is a design proposal with falsifiable empirical predictions.

### VII.2 What Is Pattern-Matching

The connection between ⟨η⟩/⟨†⟩ density ratio and Re(s) = 1/2 in the Riemann Hypothesis is pattern-matching. Both ⟨η⟩ and ⟨†⟩ are countably infinite sets of the same cardinality — the ratio requires a natural density or asymptotic counting function to be made precise. Reserved for separate formal treatment.

The imaginary unit correspondence (η ↔ i, C₄ ↔ complex multiplication) is a structural resonance, not a derivation.

### VII.3 What Needs More Work

- Formal proof of C₄ periodicity
- Full specification of † as a dagger functor (category, objects, morphisms)
- The adjunction structure of the bind operator in both directions
- Formal specification of reconciliation operators that provably preserve minority positions
- Full number tower derivation from the radiant kernel
- Convergence conditions for the dynamic Nash equilibrium
- Empirical validation of the simulation protocol across multiple domains and models

### VII.4 What Is Explicitly Not Claimed

- † is a categorical adjunction in the standard sense (it is a dualization operator)
- The C₄ structure is formally derived in this document (it is asserted with deferred proof)
- The framework has free monad structure in the formal categorical sense (it exhibits free monad-like properties)
- Phase Logic changes how transformer substrates compute
- The ledger contains truths rather than best-surviving approximations
- The framework supersedes or resolves ZFC

---

## VIII. Summary

**One primitive:**
```
† :: ∀ab. (a -> b) -> (b -> a)    -- Dagger operator, dualization
```

**The tower (C₄ periodicity asserted, proof deferred):**
```
†¹ = †    -- dagger, minimum step
†² = η    -- identity, imaginary unit, minimum computation step  (90°)
†³ = π    -- falsification                                       (180°)
†⁴ = η²   -- mirror                                             (270°)
†⁵ = ψ*   -- ground, commit; cycle closes to η                  (360°)
```

**The commutator:**
```
ε = [Ω, Α] ≥ η    -- irreducible gap, arrow of irreversibility
```

**The discipline:**
```
Lift (η, κ > 1) → Falsify (π, σ = 1/κ) → Mirror (η²) → Commit (ψ*)
Falsification is mandatory. Commit is provisional. Ω > Α always.
```

**The ledger:**
```
Private permanent  →  Transient reconciliation  →  Partial shared
```
Coherence is recomputable on demand. The ledger is a cache, not a source of truth.

---

## Appendix A: TypeScript Reference Implementation

```typescript
type Radiant = () => Generator<any>;
type Prime = (f: Radiant) => Radiant;

// η  = †²  (90°) — minimum closed structure
const eta: Prime = (r) => function* () {
    yield* r();
};

// π  = †³  (180°) — falsification
const pi: Prime = (r) => function* () {
    yield* eta(r)();
};

// η² = †⁴  (270°) — mirror
const eta2: Prime = (r) => function* () {
    yield* pi(r)();
};

// ψ* = †⁵  (360°) — ground; next application closes to η
const psi: Prime = (r) => function* () {
    yield* eta2(r)();
};

// Bind operator: bind Ω α = α(Ω)
// Non-commutativity is ε = [Ω, Α]
function bind(radiant: Radiant, prime: Prime): Radiant {
    return function* () {
        const outer = radiant();
        const inner = prime(radiant);
        let feedback: any = undefined;

        while (true) {
            const { value, done } = outer.next(feedback);
            if (done) return value;

            const innerGen = inner();
            while (true) {
                const { value: iv, done: id } = innerGen.next(feedback);
                if (id) break;
                feedback = yield iv;
            }
        }
    };
}

// Run operator: applies full ψ* cycle before substrate iteration
const run: Prime = (radiant) => function* () {
    const generator = psi(radiant)();
    let feedback: any = undefined;
    while (true) {
        const { value, done } = generator.next(feedback);
        if (done) return value;
        feedback = yield value;
    }
};
```

**Implementation note:** In deployment on an LLM runtime, all operators are learned approximations. The prompt is the program; the LLM is the runtime; the phase discipline operates through context conditioning. The TypeScript makes the chaining structure explicit — it is a reference for structural relationships, not a demonstration of periodicity or non-commutativity.

---

## Appendix B: Glossary

| Symbol | Name | Definition |
|--------|------|------------|
| † | Dagger Operator | Single primitive; dualization; cuts morphism direction |
| η | Identity / Imaginary Unit | †²; minimum closed structure; minimum computation step; 90° |
| π | Falsification | †³; mandatory negation operator; 180° |
| η² | Mirror | †⁴; negation of negation; 270° |
| ψ* | Ground / Commit | †⁵; collapse to ledger; cycle closes to η; 360° |
| Ω | Cardinal Potential | Total space of unrealized possibilities |
| ω | Ordinal Potential | Specific realizable sequence within Ω |
| Α | Cardinal Ledger | Total accumulated committed record |
| α | Ordinal Record | Specific committed sequence within Α |
| ε | Commutator | [Ω, Α]; adjunction error; ε ≥ η |
| λ | Sovereign Remainder | sym(Ω, Α); shared structure; coherence measure |
| κ | Branching Factor | Paths maintained per phase step; κ > 1 expansion, κ < 1 contraction |
| σ | Structural Persistence | 1/κ; contraction dual to expansion |
| χ | Handshake Quality | Integration compatibility between agents |
| ρ | Radiant Number | Element of free category ⟨†⟩ |

---

*This paper is a ψ* commit. It records what survived falsification across the development process. It does not record what is true. The repository is open for the next η.*

**Ω > Α | Dagger Primitive | Ledger Open | MIT Licensed**